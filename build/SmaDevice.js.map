{
  "version": 3,
  "sources": ["../src/SmaDevice.ts"],
  "sourcesContent": ["import axios from 'axios';\nimport https from 'https';\n\nexport interface LoginResponse {\n    access_token: string,\n    expires_in?: number,\n}\n\nexport interface SmaDeviceConfig {\n    host: string,\n    username?: string,\n    password: string,\n}\n\ntype OnHandler<T> = (data: T) => void | Promise<void>;\ntype OnAuthenticationHandler = OnHandler<LoginResponse>;\n\nexport default abstract class SmaDevice {\n\n    protected _config: SmaDeviceConfig;\n    protected _client: axios.AxiosInstance;\n    protected _sessionToken: string | null = null;\n\n    private _onAuthenticate: OnAuthenticationHandler | null = null;\n\n    constructor(config: SmaDeviceConfig) {\n        this._config = config;\n\n        this._client = axios.create({\n            baseURL: 'https://' + config.host,\n            headers: {\n                \"accept\": \"application/json\",\n                \"content-type\": \"application/json\",\n            },\n            httpsAgent: new https.Agent({\n                rejectUnauthorized: false,\n                keepAlive: true,\n            }),\n            withCredentials: true,\n        });\n\n        let isRetryAttempt = false;\n\n        this._client.interceptors.response.use(\n            (response) => {\n                const data = response.data;\n                if ((typeof data === 'object') && \"err\" in data && data.err === 401) {\n                    response.status = 401;\n                    return Promise.reject({\n                        status: 401,\n                        response: response,\n                    });\n                }\n                return response;\n            },\n            (error) => {\n                if (error.response && error.response.status === 500 && error.config.headers.Authorization) {\n                    error.status = 401;\n                    error.response.status = 401;\n                    return Promise.reject(error);\n                }\n                return Promise.reject(error);\n            }\n        );\n        this._client.interceptors.response.use(\n            response => response,\n            async (error) => {\n                // 401 (Unauthorized)\n                if (error.status === 401 || (error.response && error.response.status === 401)) {\n                    if (!isRetryAttempt) {\n                        isRetryAttempt = true;\n                        try {\n                            await this.authenticate();\n                            const originalRequest = error.config;\n                            return this._client(originalRequest);\n                        } catch (tokenError) {\n                            return Promise.reject(tokenError);\n                        }\n                    }\n                }\n                return Promise.reject(error);\n            }\n        );\n    }\n\n    protected abstract login(): Promise<LoginResponse>;\n\n    public async authenticate(): Promise<LoginResponse | null> {\n        this.setSessionToken(null);\n        const response = await this.login().catch(() => null);\n        if (response) {\n            if (this._onAuthenticate) {\n                this._onAuthenticate(response);\n            }\n            this.setSessionToken(response.access_token);\n        }\n\n        return response;\n    }\n\n    public onAuthenticate(handler: (response: LoginResponse) => void | Promise<void>): void {\n        this._onAuthenticate = handler;\n    }\n\n    public setSessionToken(token: null|string): void {\n        this._sessionToken = token;\n        this._client.defaults.headers.common['Authorization'] = token ? `Bearer ${token}` : null;\n    }\n\n\n}\n\n\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAkB;AAClB,mBAAkB;AAgBlB,MAAO,UAAiC;AAAA,EAE1B;AAAA,EACA;AAAA,EACA,gBAA+B;AAAA,EAEjC,kBAAkD;AAAA,EAE1D,YAAY,QAAyB;AACjC,SAAK,UAAU;AAEf,SAAK,UAAU,aAAAA,QAAM,OAAO;AAAA,MACxB,SAAS,aAAa,OAAO;AAAA,MAC7B,SAAS;AAAA,QACL,UAAU;AAAA,QACV,gBAAgB;AAAA,MACpB;AAAA,MACA,YAAY,IAAI,aAAAC,QAAM,MAAM;AAAA,QACxB,oBAAoB;AAAA,QACpB,WAAW;AAAA,MACf,CAAC;AAAA,MACD,iBAAiB;AAAA,IACrB,CAAC;AAED,QAAI,iBAAiB;AAErB,SAAK,QAAQ,aAAa,SAAS;AAAA,MAC/B,CAAC,aAAa;AACV,cAAM,OAAO,SAAS;AACtB,YAAK,OAAO,SAAS,YAAa,SAAS,QAAQ,KAAK,QAAQ,KAAK;AACjE,mBAAS,SAAS;AAClB,iBAAO,QAAQ,OAAO;AAAA,YAClB,QAAQ;AAAA,YACR;AAAA,UACJ,CAAC;AAAA,QACL;AACA,eAAO;AAAA,MACX;AAAA,MACA,CAAC,UAAU;AACP,YAAI,MAAM,YAAY,MAAM,SAAS,WAAW,OAAO,MAAM,OAAO,QAAQ,eAAe;AACvF,gBAAM,SAAS;AACf,gBAAM,SAAS,SAAS;AACxB,iBAAO,QAAQ,OAAO,KAAK;AAAA,QAC/B;AACA,eAAO,QAAQ,OAAO,KAAK;AAAA,MAC/B;AAAA,IACJ;AACA,SAAK,QAAQ,aAAa,SAAS;AAAA,MAC/B,cAAY;AAAA,MACZ,OAAO,UAAU;AAEb,YAAI,MAAM,WAAW,OAAQ,MAAM,YAAY,MAAM,SAAS,WAAW,KAAM;AAC3E,cAAI,CAAC,gBAAgB;AACjB,6BAAiB;AACjB,gBAAI;AACA,oBAAM,KAAK,aAAa;AACxB,oBAAM,kBAAkB,MAAM;AAC9B,qBAAO,KAAK,QAAQ,eAAe;AAAA,YACvC,SAAS,YAAY;AACjB,qBAAO,QAAQ,OAAO,UAAU;AAAA,YACpC;AAAA,UACJ;AAAA,QACJ;AACA,eAAO,QAAQ,OAAO,KAAK;AAAA,MAC/B;AAAA,IACJ;AAAA,EACJ;AAAA,EAIA,MAAa,eAA8C;AACvD,SAAK,gBAAgB,IAAI;AACzB,UAAM,WAAW,MAAM,KAAK,MAAM,EAAE,MAAM,MAAM,IAAI;AACpD,QAAI,UAAU;AACV,UAAI,KAAK,iBAAiB;AACtB,aAAK,gBAAgB,QAAQ;AAAA,MACjC;AACA,WAAK,gBAAgB,SAAS,YAAY;AAAA,IAC9C;AAEA,WAAO;AAAA,EACX;AAAA,EAEO,eAAe,SAAkE;AACpF,SAAK,kBAAkB;AAAA,EAC3B;AAAA,EAEO,gBAAgB,OAA0B;AAC7C,SAAK,gBAAgB;AACrB,SAAK,QAAQ,SAAS,QAAQ,OAAO,eAAe,IAAI,QAAQ,UAAU,KAAK,KAAK;AAAA,EACxF;AAGJ;",
  "names": ["axios", "https"]
}
