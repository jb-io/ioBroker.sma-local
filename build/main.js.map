{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.6.3\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from '@iobroker/adapter-core';\n\n// Load your modules here:\n// import _ from 'lodash';\nimport SmaDevice, {LoginResponse} from \"./SmaDevice\";\nimport SmaEnnexosDevice, {LiveRequestResponse, ParametersResponse} from \"./SmaEnnexosDevice\";\nimport SmaLegacyDevice, {GetValuesResponse, N0Data, N0DataNode, N1Data, N1DataNode, N9Data, N9DataNode, ObjectMetadata} from \"./SmaLegacyDevice\";\nimport {Device} from \"./data\";\n\n\nclass SmaLocal extends utils.Adapter {\n\n\n   private readonly adapterIntervals: (ioBroker.Interval | undefined)[] ;\n   private readonly adapterTimeouts: (ioBroker.Timeout | undefined)[];\n\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: 'sma-local',\n        });\n        this.on('ready', this.onReady.bind(this));\n        this.on('stateChange', this.onStateChange.bind(this));\n        this.on('unload', this.onUnload.bind(this));\n\n        this.adapterTimeouts = [];\n        this.adapterIntervals = [];\n    }\n\n\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        // Initialize your adapter here\n\n        // Reset the connection indicator during startup\n        await this.setState('info.connection', false, true);\n\n        if (!this.config.host) {\n            return;\n        }\n\n        let device: SmaDevice;\n        if (this.config.legacyDevice) {\n            device = new SmaLegacyDevice({\n                host: this.config.host,\n                password: this.config.password || '',\n            });\n        } else {\n            device = new SmaEnnexosDevice({\n                host: this.config.host,\n                username: this.config.username || '',\n                password: this.config.password || '',\n            })\n        }\n\n        device.onAuthenticate((response: LoginResponse) => {\n            if (this.config.storeSessionToken) {\n                this.extendObject('info.session', {\n                    type: 'state',\n                    common: {\n                        type: 'string',\n                        name: 'Session token',\n                        role: 'text',\n                        write: false,\n                    },\n                });\n                this.setState('info.session', {\n                    val: response.access_token,\n                    ack: true,\n                    expire: response.expires_in,\n                })\n            }\n            this.setState('info.connection', true, true);\n            this.log.info(`Authenticated with token: ${response.access_token}`);\n        })\n\n        let authenticated = false;\n        if (this.config.storeSessionToken) {\n            const session = await this.getStateAsync('info.session');\n            if (session && session.ack && session.val) {\n                device.setSessionToken(session.val as string);\n                authenticated = true;\n            }\n        }\n        if (!authenticated) {\n            await device.authenticate();\n        }\n\n        if (this.config.intervalLiveData <= 0) {\n            this.log.info(`Will not receive live data because it is disabled in your configuration.`);\n        }\n        if (this.config.intervalFull <= 0) {\n            this.log.info(`Will not receive full data because it is disabled in your configuration.`);\n        }\n\n        if (this.config.legacyDevice) {\n            await this.setupLegacyDevice(device as SmaLegacyDevice);\n        } else {\n            await this.setupEnnexosDevice(device as SmaEnnexosDevice);\n        }\n\n    }\n\n    private async setupLegacyDevice(device: SmaLegacyDevice): Promise<void> {\n\n        type ObjectKey = keyof typeof objectMetadataCollection;\n        const objectMetadataCollection = await device.getObjectMetaData();\n\n        const translations = await device.getTagTranslations();\n        const getTranslation = (tag: number|string): string => {\n            if (tag in translations) {\n                return translations[tag];\n            }\n            return `${tag}`;\n        }\n\n        const dataIdPathMapping: {[key: ObjectKey]: string} = {};\n        const getDataIdPathMapping = async (key: ObjectKey): Promise<string> => {\n            if (!(key in dataIdPathMapping)) {\n                const promises: Promise<any>[] = [];\n                let path = 'Parameter';\n                for (const pathItem of objectMetadataCollection[key].TagHier) {\n                    path += '.' + pathItem ;\n                    promises.push(this.extendObject(path, {\n                        type: 'channel',\n                        common: {\n                            name: getTranslation(pathItem),\n                        }\n                    }));\n                }\n                await Promise.all(promises);\n                dataIdPathMapping[key] = path + '.' + key;\n            }\n\n            return dataIdPathMapping[key];\n        }\n\n        const objectStateConfig: {[key: ObjectKey]: ioBroker.PartialObject} = {};\n        const getObjectStateConfig = (key: ObjectKey): ioBroker.PartialObject => {\n            if (!(key in objectStateConfig)) {\n                const metadata = objectMetadataCollection[key];\n                const common: Partial<ioBroker.StateCommon> = {\n                    role: 'state',\n                    type: 'mixed',\n                    name: getTranslation(metadata.TagId),\n                    write: metadata.WriteLevel <= 2,\n                };\n                if (metadata.Typ === 0) {\n                    common.type = 'number';\n                    common.role = 'value';\n                } else if (metadata.Typ === 2) {\n                    common.type = 'string';\n                    common.role = 'text'\n                }\n\n                if (metadata.Unit) {\n                    common.unit = getTranslation(metadata.Unit);\n                }\n\n                objectStateConfig[key] = {\n                    type: 'state',\n                    common: common,\n                    native: {...metadata}\n                };\n            }\n\n            return objectStateConfig[key];\n        }\n\n        await this.setState('info.connection', true, true);\n\n        const handleGetValuesResponse = async ({result: devices}: GetValuesResponse): Promise<void> => {\n            if (!devices) {\n                return\n            }\n\n            const transformDataNodes = (dataNode: N0DataNode|N1DataNode|N9DataNode, objectMetadata: ObjectMetadata): Array<ioBroker.StateValue>|null => {\n                let data: N0Data[]|N1Data[]|N9Data[] = [];\n                if (\"0\" in dataNode) {\n                    data = (dataNode as N0DataNode)[\"0\"];\n                } else if (\"1\" in dataNode) {\n                    data = (dataNode as N1DataNode)[\"1\"];\n                } else if (\"9\" in dataNode) {\n                    data = (dataNode as N9DataNode)[\"9\"];\n                }\n\n                if (data.length <= 0) {\n                    return null;\n                }\n\n                const normalizeValue = (value: N0Data|N1Data|N9Data): number|string|null => {\n                    const val = value.val;\n                    if (Array.isArray(val)) {\n                        if (val.length > 0) {\n                            return val.map((x) => getTranslation(x.tag)).join(', ');\n                        }\n                        return null;\n                    }\n\n                    if (typeof val === 'number' && objectMetadata.Scale) {\n                        return  val * objectMetadata.Scale;\n                    }\n                    return val;\n                }\n\n                return data.map(normalizeValue);\n            };\n\n            const deviceKey = Object.keys(devices)[0];\n            const deviceValues = devices[deviceKey];\n            const promises : Promise<any>[] = [];\n\n            this.log.debug(`Received Data for keys: ${Object.keys(deviceValues)}`);\n\n            for (const key in deviceValues) {\n\n                const deviceValue = deviceValues[key];\n                const objectMetadata = objectMetadataCollection[key];\n\n                const values = transformDataNodes(deviceValue, objectMetadata);\n                if (null === values) {\n                    continue;\n                }\n\n                promises.push((async (): Promise<any> => {\n                    const id = await getDataIdPathMapping(key);\n                    const objPart = getObjectStateConfig(key);\n                    if (values.length === 1) {\n                        await this.extendObject(id, objPart).then(() => this.setState(id, values[0], true));\n                    } else {\n                        for (let i = 0; i < values.length; i++) {\n                            const itemId = `${id}.${i}`;\n                            await this.extendObject(itemId, objPart).then(() => this.setState(itemId, values[i], true));\n                        }\n                    }\n                })());\n\n            }\n\n            await Promise.all(promises);\n        }\n\n        const requestLiveData = async () => {\n            this.log.debug('Request Live Data');\n            const response = await device.getAllOnlValues().catch((e) => {\n                this.log.error(JSON.stringify(e));\n                this.setState('info.connection', false, true);\n                return null;\n            });\n            if (response) {\n                await this.setState('info.connection', true, true);\n                await handleGetValuesResponse(response);\n            }\n        };\n        this.adapterIntervals.push(this.setInterval(requestLiveData, this.config.intervalLiveData * 1000));\n        this.adapterTimeouts.push(this.setTimeout(requestLiveData, 1000));\n\n        const requestFull = async () => {\n            const keys = Object.keys(objectMetadataCollection);\n            const chunkSize = 64;\n            const chunkCount = Math.ceil(keys.length / chunkSize);\n            let offset = 0;\n\n            const timeout = Math.round((this.config.intervalFull * 1000) / (chunkCount + 1));\n\n            const handleChunk = async () => {\n                this.log.debug(`Request Full Data Chunk ${offset} - ${offset + chunkSize} / ${keys.length}`);\n                const chunk = keys.slice(offset, offset + chunkSize);\n                offset += chunkSize;\n                if (offset < keys.length) {\n                    this.setTimeout(handleChunk, timeout);\n                }\n\n                const response = await device.getValues(chunk).catch((e) => {\n                    this.log.error(JSON.stringify(e));\n                    this.setState('info.connection', false, true);\n                    return null;\n                });\n                if (response) {\n                    await this.setState('info.connection', true, true);\n                    await handleGetValuesResponse(response);\n                }\n            }\n            await handleChunk();\n        };\n        this.adapterIntervals.push(this.setInterval(requestFull, this.config.intervalFull * 1000));\n        this.adapterTimeouts.push(this.setTimeout(requestFull, 2000));\n\n    }\n\n    private async setupEnnexosDevice(device: SmaEnnexosDevice): Promise<void> {\n\n\n        /* Widget Data\n        const widgets = (await device.getWidgets()).map(item => item.widgetType);\n        for (const widget of widgets) {\n            this.log.info(widget);\n            const widgetData = await device.getWidgetData(widget);\n            this.log.info(JSON.stringify(widgetData));\n        }\n        END Widget Data */\n\n        const devices = await device.getDeviceDefinitions();\n\n        const translations = await device.getTranslations();\n        const getTranslation = (key: string|number): string => {\n            if (key in translations) {\n                return translations[key];\n            }\n            return `${key}`;\n        }\n\n        const dataIdPathMapping: {[key: string]: string} = {};\n        const getDataIdPathMapping = async (key: string): Promise<string> => {\n            if (!(key in dataIdPathMapping)) {\n                const deviceDefinition = devices[key];\n                if (deviceDefinition && deviceDefinition.displayGroup) {\n                    await this.extendObject(key.replace(/\\.[^.]*$/, ''), {\n                        type: 'channel',\n                        common: {\n                            name: getTranslation(deviceDefinition.displayGroup),\n                        }\n                    });\n                }\n                dataIdPathMapping[key] = key;\n            }\n\n            return dataIdPathMapping[key];\n        }\n\n\n        const objectStateConfig: {[key: string]: ioBroker.PartialObject} = {};\n        const getObjectStateConfig = (key: string, config: {editable?: boolean,min?: number, max?:number, possibleValues?: string[]}|null = null): ioBroker.PartialObject => {\n            if (!(key in objectStateConfig)) {\n                const deviceDefinition: Device|undefined = devices[key];\n                const common: Partial<ioBroker.StateCommon> = {\n                    role: 'state',\n                    type: 'mixed',\n                    write: (config && config.editable !== undefined) ? config.editable : false,\n                };\n                const native: any = {};\n\n                if (deviceDefinition) {\n                    if (deviceDefinition.translationId) {\n                        common.name = getTranslation(deviceDefinition.translationId)\n                    }\n                    if (deviceDefinition.unit && parseInt(deviceDefinition.unit)) {\n                        common.unit = getTranslation(deviceDefinition.unit);\n                    }\n                    if (deviceDefinition.valueType === 'SCALAR') {\n                        common.type = 'number';\n                        common.role = 'value';\n                    } else if (deviceDefinition.valueType === 'TEXT') {\n                        common.type = 'string';\n                        common.role = 'text'\n                    }\n                    native.deviceDefinition = deviceDefinition;\n                } else {\n                    this.log.warn(`Device definition for ${key} not found.`);\n                }\n\n                if (config) {\n                    if (config.min !== undefined) {\n                        common.min = config.min;\n                    }\n                    if (config.max !== undefined) {\n                        common.max = config.max;\n                    }\n                    native.config = config;\n                }\n\n\n                objectStateConfig[key] = {\n                    type: 'state',\n                    common: common,\n                    native: native\n                };\n            }\n\n            return objectStateConfig[key];\n        }\n\n        const handleLiveDataResponse = async (data : LiveRequestResponse): Promise<void> => {\n            this.log.debug(`Received Live Data Response: ${JSON.stringify(data.map((channel) => channel.channelId))}`);\n            await this.setState('info.connection', true, true);\n            const promises : Promise<any>[] = [];\n\n            for (const channel of data) {\n                if (channel.values.length !== 1) {\n                    this.log.error(`Could not handle data for ${channel.channelId}: ${JSON.stringify(channel.values)}`);\n                }\n\n                const channelData = channel.values[0];\n                const normalizedChannelId = channel.channelId.replace(/\\[]$/, '');\n\n                promises.push((async (): Promise<any> => {\n                    const id = await getDataIdPathMapping(normalizedChannelId);\n                    const objPart = getObjectStateConfig(normalizedChannelId);\n                    if (\"value\" in channelData && channelData.value !== undefined) {\n                        await this.extendObject(id, objPart).then(() => this.setState(id, channelData.value || null, true));\n                    } else if (\"values\" in channelData && channelData.values !== undefined) {\n                        for (let index = 0; index < channelData.values.length; index++) {\n                            const itemId = `${id}.${index}`;\n                            const value = channelData.values[index] || null;\n                            await this.extendObject(itemId, objPart).then(() => this.setState(itemId, value, true));\n                        }\n                    }\n                })());\n\n            }\n\n            await Promise.all(promises);\n        }\n\n        const handleParametersResponse = async (data : ParametersResponse): Promise<void> => {\n            this.log.debug(`Received Parameters Response: ${JSON.stringify(data[0].values.map((channel) => channel.channelId))}`);\n            await this.setState('info.connection', true, true);\n            const promises : Promise<any>[] = [];\n\n            for (const channel of data[0].values) {\n\n                const normalizedChannelId = channel.channelId.replace(/\\[]$/, '');\n\n                promises.push((async (): Promise<any> => {\n                    const id = await getDataIdPathMapping(normalizedChannelId);\n                    const objPart = getObjectStateConfig(normalizedChannelId, channel);\n\n                    const transform = (value: string): ioBroker.StateValue => {\n                        if (channel.min || channel.max || /^\\d+(\\.\\d+)?$/.test(value)) {\n                            return parseFloat(value);\n                        }\n                        if (channel.possibleValues) {\n                            return getTranslation(value);\n                        }\n                        return value;\n                    }\n                    if (\"value\" in channel && channel.value !== undefined) {\n                        await this.extendObject(id, objPart).then(() => this.setState(id, transform(channel.value), true));\n                    } else if (\"values\" in channel && channel.values !== undefined) {\n                        for (let index = 0; index < channel.values.length; index++) {\n                            const itemId = `${id}.${index}`;\n                            await this.extendObject(itemId, objPart).then(() => this.setState(itemId, transform(channel.values[index]), true));\n                        }\n                    }\n                })());\n\n            }\n\n            await Promise.all(promises);\n        }\n\n        const requestLiveData = async () => {\n            this.log.debug('Request Live Data');\n            const liveMeasurementValues = await device.getLiveMeasurementValues().catch((e) => {\n                this.log.error(JSON.stringify(e));\n                this.setState('info.connection', false, true);\n                return null;\n            });\n            if (liveMeasurementValues) {\n                await handleLiveDataResponse(liveMeasurementValues);\n            }\n        };\n        this.adapterIntervals.push(this.setInterval(requestLiveData, this.config.intervalLiveData * 1000));\n        this.adapterTimeouts.push(this.setTimeout(requestLiveData, 1000));\n\n        const requestParameters = async () => {\n            this.log.debug(`Request Parameters Data`);\n            const parametersResponse = await device.getParameters().catch((e) => {\n                this.log.error(JSON.stringify(e));\n                this.setState('info.connection', false, true);\n                return null;\n            });\n            if (parametersResponse) {\n                await handleParametersResponse(parametersResponse);\n            }\n\n        };\n        this.adapterIntervals.push(this.setInterval(requestParameters, this.config.intervalFull * 1000));\n        this.adapterTimeouts.push(this.setTimeout(requestParameters, 2000));\n    }\n\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    private async onStateChange(id: string, state: ioBroker.State | null | undefined): Promise<void> {\n        if (state) {\n\n\n        } else {\n            // The state was deleted\n            this.log.debug(`state ${id} deleted`);\n            // this.setTimeout(this.createStates.bind(this), 1000);\n        }\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            // Here you must clear all timeouts or intervals that may still be active\n            for (const timeout of this.adapterTimeouts) {\n                this.clearTimeout(timeout);\n            }\n            for (const interval of this.adapterIntervals) {\n                this.clearInterval(interval);\n            }\n\n            callback();\n        } catch {\n            callback();\n        }\n    }\n\n\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new SmaLocal(options);\n} else {\n    // otherwise start the instance directly\n    (() => new SmaLocal())();\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAMA,YAAuB;AAKvB,8BAAwE;AACxE,6BAA6H;AAI7H,MAAM,iBAAiB,MAAM,QAAQ;AAAA,EAGjB;AAAA,EACA;AAAA,EAGT,YAAY,UAAyC,CAAC,GAAG;AAC5D,UAAM;AAAA,MACF,GAAG;AAAA,MACH,MAAM;AAAA,IACV,CAAC;AACD,SAAK,GAAG,SAAS,KAAK,QAAQ,KAAK,IAAI,CAAC;AACxC,SAAK,GAAG,eAAe,KAAK,cAAc,KAAK,IAAI,CAAC;AACpD,SAAK,GAAG,UAAU,KAAK,SAAS,KAAK,IAAI,CAAC;AAE1C,SAAK,kBAAkB,CAAC;AACxB,SAAK,mBAAmB,CAAC;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAOA,MAAc,UAAyB;AAInC,UAAM,KAAK,SAAS,mBAAmB,OAAO,IAAI;AAElD,QAAI,CAAC,KAAK,OAAO,MAAM;AACnB;AAAA,IACJ;AAEA,QAAI;AACJ,QAAI,KAAK,OAAO,cAAc;AAC1B,eAAS,IAAI,uBAAAA,QAAgB;AAAA,QACzB,MAAM,KAAK,OAAO;AAAA,QAClB,UAAU,KAAK,OAAO,YAAY;AAAA,MACtC,CAAC;AAAA,IACL,OAAO;AACH,eAAS,IAAI,wBAAAC,QAAiB;AAAA,QAC1B,MAAM,KAAK,OAAO;AAAA,QAClB,UAAU,KAAK,OAAO,YAAY;AAAA,QAClC,UAAU,KAAK,OAAO,YAAY;AAAA,MACtC,CAAC;AAAA,IACL;AAEA,WAAO,eAAe,CAAC,aAA4B;AAC/C,UAAI,KAAK,OAAO,mBAAmB;AAC/B,aAAK,aAAa,gBAAgB;AAAA,UAC9B,MAAM;AAAA,UACN,QAAQ;AAAA,YACJ,MAAM;AAAA,YACN,MAAM;AAAA,YACN,MAAM;AAAA,YACN,OAAO;AAAA,UACX;AAAA,QACJ,CAAC;AACD,aAAK,SAAS,gBAAgB;AAAA,UAC1B,KAAK,SAAS;AAAA,UACd,KAAK;AAAA,UACL,QAAQ,SAAS;AAAA,QACrB,CAAC;AAAA,MACL;AACA,WAAK,SAAS,mBAAmB,MAAM,IAAI;AAC3C,WAAK,IAAI,KAAK,6BAA6B,SAAS,YAAY,EAAE;AAAA,IACtE,CAAC;AAED,QAAI,gBAAgB;AACpB,QAAI,KAAK,OAAO,mBAAmB;AAC/B,YAAM,UAAU,MAAM,KAAK,cAAc,cAAc;AACvD,UAAI,WAAW,QAAQ,OAAO,QAAQ,KAAK;AACvC,eAAO,gBAAgB,QAAQ,GAAa;AAC5C,wBAAgB;AAAA,MACpB;AAAA,IACJ;AACA,QAAI,CAAC,eAAe;AAChB,YAAM,OAAO,aAAa;AAAA,IAC9B;AAEA,QAAI,KAAK,OAAO,oBAAoB,GAAG;AACnC,WAAK,IAAI,KAAK,0EAA0E;AAAA,IAC5F;AACA,QAAI,KAAK,OAAO,gBAAgB,GAAG;AAC/B,WAAK,IAAI,KAAK,0EAA0E;AAAA,IAC5F;AAEA,QAAI,KAAK,OAAO,cAAc;AAC1B,YAAM,KAAK,kBAAkB,MAAyB;AAAA,IAC1D,OAAO;AACH,YAAM,KAAK,mBAAmB,MAA0B;AAAA,IAC5D;AAAA,EAEJ;AAAA,EAEA,MAAc,kBAAkB,QAAwC;AAGpE,UAAM,2BAA2B,MAAM,OAAO,kBAAkB;AAEhE,UAAM,eAAe,MAAM,OAAO,mBAAmB;AACrD,UAAM,iBAAiB,CAAC,QAA+B;AACnD,UAAI,OAAO,cAAc;AACrB,eAAO,aAAa,GAAG;AAAA,MAC3B;AACA,aAAO,GAAG,GAAG;AAAA,IACjB;AAEA,UAAM,oBAAgD,CAAC;AACvD,UAAM,uBAAuB,OAAO,QAAoC;AACpE,UAAI,EAAE,OAAO,oBAAoB;AAC7B,cAAM,WAA2B,CAAC;AAClC,YAAI,OAAO;AACX,mBAAW,YAAY,yBAAyB,GAAG,EAAE,SAAS;AAC1D,kBAAQ,MAAM;AACd,mBAAS,KAAK,KAAK,aAAa,MAAM;AAAA,YAClC,MAAM;AAAA,YACN,QAAQ;AAAA,cACJ,MAAM,eAAe,QAAQ;AAAA,YACjC;AAAA,UACJ,CAAC,CAAC;AAAA,QACN;AACA,cAAM,QAAQ,IAAI,QAAQ;AAC1B,0BAAkB,GAAG,IAAI,OAAO,MAAM;AAAA,MAC1C;AAEA,aAAO,kBAAkB,GAAG;AAAA,IAChC;AAEA,UAAM,oBAAgE,CAAC;AACvE,UAAM,uBAAuB,CAAC,QAA2C;AACrE,UAAI,EAAE,OAAO,oBAAoB;AAC7B,cAAM,WAAW,yBAAyB,GAAG;AAC7C,cAAM,SAAwC;AAAA,UAC1C,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM,eAAe,SAAS,KAAK;AAAA,UACnC,OAAO,SAAS,cAAc;AAAA,QAClC;AACA,YAAI,SAAS,QAAQ,GAAG;AACpB,iBAAO,OAAO;AACd,iBAAO,OAAO;AAAA,QAClB,WAAW,SAAS,QAAQ,GAAG;AAC3B,iBAAO,OAAO;AACd,iBAAO,OAAO;AAAA,QAClB;AAEA,YAAI,SAAS,MAAM;AACf,iBAAO,OAAO,eAAe,SAAS,IAAI;AAAA,QAC9C;AAEA,0BAAkB,GAAG,IAAI;AAAA,UACrB,MAAM;AAAA,UACN;AAAA,UACA,QAAQ,EAAC,GAAG,SAAQ;AAAA,QACxB;AAAA,MACJ;AAEA,aAAO,kBAAkB,GAAG;AAAA,IAChC;AAEA,UAAM,KAAK,SAAS,mBAAmB,MAAM,IAAI;AAEjD,UAAM,0BAA0B,OAAO,EAAC,QAAQ,QAAO,MAAwC;AAC3F,UAAI,CAAC,SAAS;AACV;AAAA,MACJ;AAEA,YAAM,qBAAqB,CAAC,UAA4C,mBAAoE;AACxI,YAAI,OAAmC,CAAC;AACxC,YAAI,OAAO,UAAU;AACjB,iBAAQ,SAAwB,GAAG;AAAA,QACvC,WAAW,OAAO,UAAU;AACxB,iBAAQ,SAAwB,GAAG;AAAA,QACvC,WAAW,OAAO,UAAU;AACxB,iBAAQ,SAAwB,GAAG;AAAA,QACvC;AAEA,YAAI,KAAK,UAAU,GAAG;AAClB,iBAAO;AAAA,QACX;AAEA,cAAM,iBAAiB,CAAC,UAAoD;AACxE,gBAAM,MAAM,MAAM;AAClB,cAAI,MAAM,QAAQ,GAAG,GAAG;AACpB,gBAAI,IAAI,SAAS,GAAG;AAChB,qBAAO,IAAI,IAAI,CAAC,MAAM,eAAe,EAAE,GAAG,CAAC,EAAE,KAAK,IAAI;AAAA,YAC1D;AACA,mBAAO;AAAA,UACX;AAEA,cAAI,OAAO,QAAQ,YAAY,eAAe,OAAO;AACjD,mBAAQ,MAAM,eAAe;AAAA,UACjC;AACA,iBAAO;AAAA,QACX;AAEA,eAAO,KAAK,IAAI,cAAc;AAAA,MAClC;AAEA,YAAM,YAAY,OAAO,KAAK,OAAO,EAAE,CAAC;AACxC,YAAM,eAAe,QAAQ,SAAS;AACtC,YAAM,WAA4B,CAAC;AAEnC,WAAK,IAAI,MAAM,2BAA2B,OAAO,KAAK,YAAY,CAAC,EAAE;AAErE,iBAAW,OAAO,cAAc;AAE5B,cAAM,cAAc,aAAa,GAAG;AACpC,cAAM,iBAAiB,yBAAyB,GAAG;AAEnD,cAAM,SAAS,mBAAmB,aAAa,cAAc;AAC7D,YAAI,SAAS,QAAQ;AACjB;AAAA,QACJ;AAEA,iBAAS,MAAM,YAA0B;AACrC,gBAAM,KAAK,MAAM,qBAAqB,GAAG;AACzC,gBAAM,UAAU,qBAAqB,GAAG;AACxC,cAAI,OAAO,WAAW,GAAG;AACrB,kBAAM,KAAK,aAAa,IAAI,OAAO,EAAE,KAAK,MAAM,KAAK,SAAS,IAAI,OAAO,CAAC,GAAG,IAAI,CAAC;AAAA,UACtF,OAAO;AACH,qBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,oBAAM,SAAS,GAAG,EAAE,IAAI,CAAC;AACzB,oBAAM,KAAK,aAAa,QAAQ,OAAO,EAAE,KAAK,MAAM,KAAK,SAAS,QAAQ,OAAO,CAAC,GAAG,IAAI,CAAC;AAAA,YAC9F;AAAA,UACJ;AAAA,QACJ,GAAG,CAAC;AAAA,MAER;AAEA,YAAM,QAAQ,IAAI,QAAQ;AAAA,IAC9B;AAEA,UAAM,kBAAkB,YAAY;AAChC,WAAK,IAAI,MAAM,mBAAmB;AAClC,YAAM,WAAW,MAAM,OAAO,gBAAgB,EAAE,MAAM,CAAC,MAAM;AACzD,aAAK,IAAI,MAAM,KAAK,UAAU,CAAC,CAAC;AAChC,aAAK,SAAS,mBAAmB,OAAO,IAAI;AAC5C,eAAO;AAAA,MACX,CAAC;AACD,UAAI,UAAU;AACV,cAAM,KAAK,SAAS,mBAAmB,MAAM,IAAI;AACjD,cAAM,wBAAwB,QAAQ;AAAA,MAC1C;AAAA,IACJ;AACA,SAAK,iBAAiB,KAAK,KAAK,YAAY,iBAAiB,KAAK,OAAO,mBAAmB,GAAI,CAAC;AACjG,SAAK,gBAAgB,KAAK,KAAK,WAAW,iBAAiB,GAAI,CAAC;AAEhE,UAAM,cAAc,YAAY;AAC5B,YAAM,OAAO,OAAO,KAAK,wBAAwB;AACjD,YAAM,YAAY;AAClB,YAAM,aAAa,KAAK,KAAK,KAAK,SAAS,SAAS;AACpD,UAAI,SAAS;AAEb,YAAM,UAAU,KAAK,MAAO,KAAK,OAAO,eAAe,OAAS,aAAa,EAAE;AAE/E,YAAM,cAAc,YAAY;AAC5B,aAAK,IAAI,MAAM,2BAA2B,MAAM,MAAM,SAAS,SAAS,MAAM,KAAK,MAAM,EAAE;AAC3F,cAAM,QAAQ,KAAK,MAAM,QAAQ,SAAS,SAAS;AACnD,kBAAU;AACV,YAAI,SAAS,KAAK,QAAQ;AACtB,eAAK,WAAW,aAAa,OAAO;AAAA,QACxC;AAEA,cAAM,WAAW,MAAM,OAAO,UAAU,KAAK,EAAE,MAAM,CAAC,MAAM;AACxD,eAAK,IAAI,MAAM,KAAK,UAAU,CAAC,CAAC;AAChC,eAAK,SAAS,mBAAmB,OAAO,IAAI;AAC5C,iBAAO;AAAA,QACX,CAAC;AACD,YAAI,UAAU;AACV,gBAAM,KAAK,SAAS,mBAAmB,MAAM,IAAI;AACjD,gBAAM,wBAAwB,QAAQ;AAAA,QAC1C;AAAA,MACJ;AACA,YAAM,YAAY;AAAA,IACtB;AACA,SAAK,iBAAiB,KAAK,KAAK,YAAY,aAAa,KAAK,OAAO,eAAe,GAAI,CAAC;AACzF,SAAK,gBAAgB,KAAK,KAAK,WAAW,aAAa,GAAI,CAAC;AAAA,EAEhE;AAAA,EAEA,MAAc,mBAAmB,QAAyC;AAYtE,UAAM,UAAU,MAAM,OAAO,qBAAqB;AAElD,UAAM,eAAe,MAAM,OAAO,gBAAgB;AAClD,UAAM,iBAAiB,CAAC,QAA+B;AACnD,UAAI,OAAO,cAAc;AACrB,eAAO,aAAa,GAAG;AAAA,MAC3B;AACA,aAAO,GAAG,GAAG;AAAA,IACjB;AAEA,UAAM,oBAA6C,CAAC;AACpD,UAAM,uBAAuB,OAAO,QAAiC;AACjE,UAAI,EAAE,OAAO,oBAAoB;AAC7B,cAAM,mBAAmB,QAAQ,GAAG;AACpC,YAAI,oBAAoB,iBAAiB,cAAc;AACnD,gBAAM,KAAK,aAAa,IAAI,QAAQ,YAAY,EAAE,GAAG;AAAA,YACjD,MAAM;AAAA,YACN,QAAQ;AAAA,cACJ,MAAM,eAAe,iBAAiB,YAAY;AAAA,YACtD;AAAA,UACJ,CAAC;AAAA,QACL;AACA,0BAAkB,GAAG,IAAI;AAAA,MAC7B;AAEA,aAAO,kBAAkB,GAAG;AAAA,IAChC;AAGA,UAAM,oBAA6D,CAAC;AACpE,UAAM,uBAAuB,CAAC,KAAa,SAAyF,SAAiC;AACjK,UAAI,EAAE,OAAO,oBAAoB;AAC7B,cAAM,mBAAqC,QAAQ,GAAG;AACtD,cAAM,SAAwC;AAAA,UAC1C,MAAM;AAAA,UACN,MAAM;AAAA,UACN,OAAQ,UAAU,OAAO,aAAa,SAAa,OAAO,WAAW;AAAA,QACzE;AACA,cAAM,SAAc,CAAC;AAErB,YAAI,kBAAkB;AAClB,cAAI,iBAAiB,eAAe;AAChC,mBAAO,OAAO,eAAe,iBAAiB,aAAa;AAAA,UAC/D;AACA,cAAI,iBAAiB,QAAQ,SAAS,iBAAiB,IAAI,GAAG;AAC1D,mBAAO,OAAO,eAAe,iBAAiB,IAAI;AAAA,UACtD;AACA,cAAI,iBAAiB,cAAc,UAAU;AACzC,mBAAO,OAAO;AACd,mBAAO,OAAO;AAAA,UAClB,WAAW,iBAAiB,cAAc,QAAQ;AAC9C,mBAAO,OAAO;AACd,mBAAO,OAAO;AAAA,UAClB;AACA,iBAAO,mBAAmB;AAAA,QAC9B,OAAO;AACH,eAAK,IAAI,KAAK,yBAAyB,GAAG,aAAa;AAAA,QAC3D;AAEA,YAAI,QAAQ;AACR,cAAI,OAAO,QAAQ,QAAW;AAC1B,mBAAO,MAAM,OAAO;AAAA,UACxB;AACA,cAAI,OAAO,QAAQ,QAAW;AAC1B,mBAAO,MAAM,OAAO;AAAA,UACxB;AACA,iBAAO,SAAS;AAAA,QACpB;AAGA,0BAAkB,GAAG,IAAI;AAAA,UACrB,MAAM;AAAA,UACN;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AAEA,aAAO,kBAAkB,GAAG;AAAA,IAChC;AAEA,UAAM,yBAAyB,OAAO,SAA8C;AAChF,WAAK,IAAI,MAAM,gCAAgC,KAAK,UAAU,KAAK,IAAI,CAAC,YAAY,QAAQ,SAAS,CAAC,CAAC,EAAE;AACzG,YAAM,KAAK,SAAS,mBAAmB,MAAM,IAAI;AACjD,YAAM,WAA4B,CAAC;AAEnC,iBAAW,WAAW,MAAM;AACxB,YAAI,QAAQ,OAAO,WAAW,GAAG;AAC7B,eAAK,IAAI,MAAM,6BAA6B,QAAQ,SAAS,KAAK,KAAK,UAAU,QAAQ,MAAM,CAAC,EAAE;AAAA,QACtG;AAEA,cAAM,cAAc,QAAQ,OAAO,CAAC;AACpC,cAAM,sBAAsB,QAAQ,UAAU,QAAQ,QAAQ,EAAE;AAEhE,iBAAS,MAAM,YAA0B;AACrC,gBAAM,KAAK,MAAM,qBAAqB,mBAAmB;AACzD,gBAAM,UAAU,qBAAqB,mBAAmB;AACxD,cAAI,WAAW,eAAe,YAAY,UAAU,QAAW;AAC3D,kBAAM,KAAK,aAAa,IAAI,OAAO,EAAE,KAAK,MAAM,KAAK,SAAS,IAAI,YAAY,SAAS,MAAM,IAAI,CAAC;AAAA,UACtG,WAAW,YAAY,eAAe,YAAY,WAAW,QAAW;AACpE,qBAAS,QAAQ,GAAG,QAAQ,YAAY,OAAO,QAAQ,SAAS;AAC5D,oBAAM,SAAS,GAAG,EAAE,IAAI,KAAK;AAC7B,oBAAM,QAAQ,YAAY,OAAO,KAAK,KAAK;AAC3C,oBAAM,KAAK,aAAa,QAAQ,OAAO,EAAE,KAAK,MAAM,KAAK,SAAS,QAAQ,OAAO,IAAI,CAAC;AAAA,YAC1F;AAAA,UACJ;AAAA,QACJ,GAAG,CAAC;AAAA,MAER;AAEA,YAAM,QAAQ,IAAI,QAAQ;AAAA,IAC9B;AAEA,UAAM,2BAA2B,OAAO,SAA6C;AACjF,WAAK,IAAI,MAAM,iCAAiC,KAAK,UAAU,KAAK,CAAC,EAAE,OAAO,IAAI,CAAC,YAAY,QAAQ,SAAS,CAAC,CAAC,EAAE;AACpH,YAAM,KAAK,SAAS,mBAAmB,MAAM,IAAI;AACjD,YAAM,WAA4B,CAAC;AAEnC,iBAAW,WAAW,KAAK,CAAC,EAAE,QAAQ;AAElC,cAAM,sBAAsB,QAAQ,UAAU,QAAQ,QAAQ,EAAE;AAEhE,iBAAS,MAAM,YAA0B;AACrC,gBAAM,KAAK,MAAM,qBAAqB,mBAAmB;AACzD,gBAAM,UAAU,qBAAqB,qBAAqB,OAAO;AAEjE,gBAAM,YAAY,CAAC,UAAuC;AACtD,gBAAI,QAAQ,OAAO,QAAQ,OAAO,gBAAgB,KAAK,KAAK,GAAG;AAC3D,qBAAO,WAAW,KAAK;AAAA,YAC3B;AACA,gBAAI,QAAQ,gBAAgB;AACxB,qBAAO,eAAe,KAAK;AAAA,YAC/B;AACA,mBAAO;AAAA,UACX;AACA,cAAI,WAAW,WAAW,QAAQ,UAAU,QAAW;AACnD,kBAAM,KAAK,aAAa,IAAI,OAAO,EAAE,KAAK,MAAM,KAAK,SAAS,IAAI,UAAU,QAAQ,KAAK,GAAG,IAAI,CAAC;AAAA,UACrG,WAAW,YAAY,WAAW,QAAQ,WAAW,QAAW;AAC5D,qBAAS,QAAQ,GAAG,QAAQ,QAAQ,OAAO,QAAQ,SAAS;AACxD,oBAAM,SAAS,GAAG,EAAE,IAAI,KAAK;AAC7B,oBAAM,KAAK,aAAa,QAAQ,OAAO,EAAE,KAAK,MAAM,KAAK,SAAS,QAAQ,UAAU,QAAQ,OAAO,KAAK,CAAC,GAAG,IAAI,CAAC;AAAA,YACrH;AAAA,UACJ;AAAA,QACJ,GAAG,CAAC;AAAA,MAER;AAEA,YAAM,QAAQ,IAAI,QAAQ;AAAA,IAC9B;AAEA,UAAM,kBAAkB,YAAY;AAChC,WAAK,IAAI,MAAM,mBAAmB;AAClC,YAAM,wBAAwB,MAAM,OAAO,yBAAyB,EAAE,MAAM,CAAC,MAAM;AAC/E,aAAK,IAAI,MAAM,KAAK,UAAU,CAAC,CAAC;AAChC,aAAK,SAAS,mBAAmB,OAAO,IAAI;AAC5C,eAAO;AAAA,MACX,CAAC;AACD,UAAI,uBAAuB;AACvB,cAAM,uBAAuB,qBAAqB;AAAA,MACtD;AAAA,IACJ;AACA,SAAK,iBAAiB,KAAK,KAAK,YAAY,iBAAiB,KAAK,OAAO,mBAAmB,GAAI,CAAC;AACjG,SAAK,gBAAgB,KAAK,KAAK,WAAW,iBAAiB,GAAI,CAAC;AAEhE,UAAM,oBAAoB,YAAY;AAClC,WAAK,IAAI,MAAM,yBAAyB;AACxC,YAAM,qBAAqB,MAAM,OAAO,cAAc,EAAE,MAAM,CAAC,MAAM;AACjE,aAAK,IAAI,MAAM,KAAK,UAAU,CAAC,CAAC;AAChC,aAAK,SAAS,mBAAmB,OAAO,IAAI;AAC5C,eAAO;AAAA,MACX,CAAC;AACD,UAAI,oBAAoB;AACpB,cAAM,yBAAyB,kBAAkB;AAAA,MACrD;AAAA,IAEJ;AACA,SAAK,iBAAiB,KAAK,KAAK,YAAY,mBAAmB,KAAK,OAAO,eAAe,GAAI,CAAC;AAC/F,SAAK,gBAAgB,KAAK,KAAK,WAAW,mBAAmB,GAAI,CAAC;AAAA,EACtE;AAAA;AAAA;AAAA;AAAA,EAMA,MAAc,cAAc,IAAY,OAAyD;AAC7F,QAAI,OAAO;AAAA,IAGX,OAAO;AAEH,WAAK,IAAI,MAAM,SAAS,EAAE,UAAU;AAAA,IAExC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKQ,SAAS,UAA4B;AACzC,QAAI;AAEA,iBAAW,WAAW,KAAK,iBAAiB;AACxC,aAAK,aAAa,OAAO;AAAA,MAC7B;AACA,iBAAW,YAAY,KAAK,kBAAkB;AAC1C,aAAK,cAAc,QAAQ;AAAA,MAC/B;AAEA,eAAS;AAAA,IACb,QAAQ;AACJ,eAAS;AAAA,IACb;AAAA,EACJ;AAGJ;AAEA,IAAI,QAAQ,SAAS,QAAQ;AAEzB,SAAO,UAAU,CAAC,YAAuD,IAAI,SAAS,OAAO;AACjG,OAAO;AAEH,GAAC,MAAM,IAAI,SAAS,GAAG;AAC3B;",
  "names": ["SmaLegacyDevice", "SmaEnnexosDevice"]
}
